"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micromark-util-subtokenize";
exports.ids = ["vendor-chunks/micromark-util-subtokenize"];
exports.modules = {

/***/ "(ssr)/./node_modules/micromark-util-subtokenize/dev/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/micromark-util-subtokenize/dev/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SpliceBuffer: () => (/* reexport safe */ _lib_splice_buffer_js__WEBPACK_IMPORTED_MODULE_0__.SpliceBuffer),\n/* harmony export */   subtokenize: () => (/* binding */ subtokenize)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! devlop */ \"(ssr)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var micromark_util_chunked__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-chunked */ \"(ssr)/./node_modules/micromark-util-chunked/dev/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/micromark-util-symbol/lib/types.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var _lib_splice_buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/splice-buffer.js */ \"(ssr)/./node_modules/micromark-util-subtokenize/dev/lib/splice-buffer.js\");\n/**\n * @import {Chunk, Event, Token} from 'micromark-util-types'\n */ \n\n\n\n// Hidden API exposed for testing.\n\n/**\n * Tokenize subcontent.\n *\n * @param {Array<Event>} eventsArray\n *   List of events.\n * @returns {boolean}\n *   Whether subtokens were found.\n */ // eslint-disable-next-line complexity\nfunction subtokenize(eventsArray) {\n    /** @type {Record<string, number>} */ const jumps = {};\n    let index = -1;\n    /** @type {Event} */ let event;\n    /** @type {number | undefined} */ let lineIndex;\n    /** @type {number} */ let otherIndex;\n    /** @type {Event} */ let otherEvent;\n    /** @type {Array<Event>} */ let parameters;\n    /** @type {Array<Event>} */ let subevents;\n    /** @type {boolean | undefined} */ let more;\n    const events = new _lib_splice_buffer_js__WEBPACK_IMPORTED_MODULE_0__.SpliceBuffer(eventsArray);\n    while(++index < events.length){\n        while(index in jumps){\n            index = jumps[index];\n        }\n        event = events.get(index);\n        // Add a hook for the GFM tasklist extension, which needs to know if text\n        // is in the first content of a list item.\n        if (index && event[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.types.chunkFlow && events.get(index - 1)[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.types.listItemPrefix) {\n            (0,devlop__WEBPACK_IMPORTED_MODULE_2__.ok)(event[1]._tokenizer, \"expected `_tokenizer` on subtokens\");\n            subevents = event[1]._tokenizer.events;\n            otherIndex = 0;\n            if (otherIndex < subevents.length && subevents[otherIndex][1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.types.lineEndingBlank) {\n                otherIndex += 2;\n            }\n            if (otherIndex < subevents.length && subevents[otherIndex][1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.types.content) {\n                while(++otherIndex < subevents.length){\n                    if (subevents[otherIndex][1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.types.content) {\n                        break;\n                    }\n                    if (subevents[otherIndex][1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.types.chunkText) {\n                        subevents[otherIndex][1]._isInFirstContentOfListItem = true;\n                        otherIndex++;\n                    }\n                }\n            }\n        }\n        // Enter.\n        if (event[0] === \"enter\") {\n            if (event[1].contentType) {\n                Object.assign(jumps, subcontent(events, index));\n                index = jumps[index];\n                more = true;\n            }\n        } else if (event[1]._container) {\n            otherIndex = index;\n            lineIndex = undefined;\n            while(otherIndex--){\n                otherEvent = events.get(otherIndex);\n                if (otherEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.types.lineEnding || otherEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.types.lineEndingBlank) {\n                    if (otherEvent[0] === \"enter\") {\n                        if (lineIndex) {\n                            events.get(lineIndex)[1].type = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.types.lineEndingBlank;\n                        }\n                        otherEvent[1].type = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.types.lineEnding;\n                        lineIndex = otherIndex;\n                    }\n                } else if (otherEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.types.linePrefix) {\n                // Move past.\n                } else {\n                    break;\n                }\n            }\n            if (lineIndex) {\n                // Fix position.\n                event[1].end = {\n                    ...events.get(lineIndex)[1].start\n                };\n                // Switch container exit w/ line endings.\n                parameters = events.slice(lineIndex, index);\n                parameters.unshift(event);\n                events.splice(lineIndex, index - lineIndex + 1, parameters);\n            }\n        }\n    }\n    // The changes to the `events` buffer must be copied back into the eventsArray\n    (0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_3__.splice)(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));\n    return !more;\n}\n/**\n * Tokenize embedded tokens.\n *\n * @param {SpliceBuffer<Event>} events\n *   Events.\n * @param {number} eventIndex\n *   Index.\n * @returns {Record<string, number>}\n *   Gaps.\n */ function subcontent(events, eventIndex) {\n    const token = events.get(eventIndex)[1];\n    const context = events.get(eventIndex)[2];\n    let startPosition = eventIndex - 1;\n    /** @type {Array<number>} */ const startPositions = [];\n    (0,devlop__WEBPACK_IMPORTED_MODULE_2__.ok)(token.contentType, \"expected `contentType` on subtokens\");\n    const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);\n    const childEvents = tokenizer.events;\n    /** @type {Array<[number, number]>} */ const jumps = [];\n    /** @type {Record<string, number>} */ const gaps = {};\n    /** @type {Array<Chunk>} */ let stream;\n    /** @type {Token | undefined} */ let previous;\n    let index = -1;\n    /** @type {Token | undefined} */ let current = token;\n    let adjust = 0;\n    let start = 0;\n    const breaks = [\n        start\n    ];\n    // Loop forward through the linked tokens to pass them in order to the\n    // subtokenizer.\n    while(current){\n        // Find the position of the event for this token.\n        while(events.get(++startPosition)[1] !== current){\n        // Empty.\n        }\n        (0,devlop__WEBPACK_IMPORTED_MODULE_2__.ok)(!previous || current.previous === previous, \"expected previous to match\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_2__.ok)(!previous || previous.next === current, \"expected next to match\");\n        startPositions.push(startPosition);\n        if (!current._tokenizer) {\n            stream = context.sliceStream(current);\n            if (!current.next) {\n                stream.push(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.eof);\n            }\n            if (previous) {\n                tokenizer.defineSkip(current.start);\n            }\n            if (current._isInFirstContentOfListItem) {\n                tokenizer._gfmTasklistFirstContentOfListItem = true;\n            }\n            tokenizer.write(stream);\n            if (current._isInFirstContentOfListItem) {\n                tokenizer._gfmTasklistFirstContentOfListItem = undefined;\n            }\n        }\n        // Unravel the next token.\n        previous = current;\n        current = current.next;\n    }\n    // Now, loop back through all events (and linked tokens), to figure out which\n    // parts belong where.\n    current = token;\n    while(++index < childEvents.length){\n        if (// Find a void token that includes a break.\n        childEvents[index][0] === \"exit\" && childEvents[index - 1][0] === \"enter\" && childEvents[index][1].type === childEvents[index - 1][1].type && childEvents[index][1].start.line !== childEvents[index][1].end.line) {\n            (0,devlop__WEBPACK_IMPORTED_MODULE_2__.ok)(current, \"expected a current token\");\n            start = index + 1;\n            breaks.push(start);\n            // Help GC.\n            current._tokenizer = undefined;\n            current.previous = undefined;\n            current = current.next;\n        }\n    }\n    // Help GC.\n    tokenizer.events = [];\n    // If there’s one more token (which is the cases for lines that end in an\n    // EOF), that’s perfect: the last point we found starts it.\n    // If there isn’t then make sure any remaining content is added to it.\n    if (current) {\n        // Help GC.\n        current._tokenizer = undefined;\n        current.previous = undefined;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_2__.ok)(!current.next, \"expected no next token\");\n    } else {\n        breaks.pop();\n    }\n    // Now splice the events from the subtokenizer into the current events,\n    // moving back to front so that splice indices aren’t affected.\n    index = breaks.length;\n    while(index--){\n        const slice = childEvents.slice(breaks[index], breaks[index + 1]);\n        const start = startPositions.pop();\n        (0,devlop__WEBPACK_IMPORTED_MODULE_2__.ok)(start !== undefined, \"expected a start position when splicing\");\n        jumps.push([\n            start,\n            start + slice.length - 1\n        ]);\n        events.splice(start, 2, slice);\n    }\n    jumps.reverse();\n    index = -1;\n    while(++index < jumps.length){\n        gaps[adjust + jumps[index][0]] = adjust + jumps[index][1];\n        adjust += jumps[index][1] - jumps[index][0] - 1;\n    }\n    return gaps;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLXV0aWwtc3VidG9rZW5pemUvZGV2L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7Q0FFQyxHQUVrQztBQUNVO0FBQ0s7QUFDQztBQUVuRCxrQ0FBa0M7QUFDaUI7QUFFbkQ7Ozs7Ozs7Q0FPQyxHQUNELHNDQUFzQztBQUMvQixTQUFTTSxZQUFZQyxXQUFXO0lBQ3JDLG1DQUFtQyxHQUNuQyxNQUFNQyxRQUFRLENBQUM7SUFDZixJQUFJQyxRQUFRLENBQUM7SUFDYixrQkFBa0IsR0FDbEIsSUFBSUM7SUFDSiwrQkFBK0IsR0FDL0IsSUFBSUM7SUFDSixtQkFBbUIsR0FDbkIsSUFBSUM7SUFDSixrQkFBa0IsR0FDbEIsSUFBSUM7SUFDSix5QkFBeUIsR0FDekIsSUFBSUM7SUFDSix5QkFBeUIsR0FDekIsSUFBSUM7SUFDSixnQ0FBZ0MsR0FDaEMsSUFBSUM7SUFDSixNQUFNQyxTQUFTLElBQUlaLCtEQUFZQSxDQUFDRTtJQUVoQyxNQUFPLEVBQUVFLFFBQVFRLE9BQU9DLE1BQU0sQ0FBRTtRQUM5QixNQUFPVCxTQUFTRCxNQUFPO1lBQ3JCQyxRQUFRRCxLQUFLLENBQUNDLE1BQU07UUFDdEI7UUFFQUMsUUFBUU8sT0FBT0UsR0FBRyxDQUFDVjtRQUVuQix5RUFBeUU7UUFDekUsMENBQTBDO1FBQzFDLElBQ0VBLFNBQ0FDLEtBQUssQ0FBQyxFQUFFLENBQUNVLElBQUksS0FBS2hCLHdEQUFLQSxDQUFDaUIsU0FBUyxJQUNqQ0osT0FBT0UsR0FBRyxDQUFDVixRQUFRLEVBQUUsQ0FBQyxFQUFFLENBQUNXLElBQUksS0FBS2hCLHdEQUFLQSxDQUFDa0IsY0FBYyxFQUN0RDtZQUNBckIsMENBQU1BLENBQUNTLEtBQUssQ0FBQyxFQUFFLENBQUNhLFVBQVUsRUFBRTtZQUM1QlIsWUFBWUwsS0FBSyxDQUFDLEVBQUUsQ0FBQ2EsVUFBVSxDQUFDTixNQUFNO1lBQ3RDTCxhQUFhO1lBRWIsSUFDRUEs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RTtJQUN0RSxJQUFJb0MsU0FBUztRQUNYLFdBQVc7UUFDWEEsUUFBUTlCLFVBQVUsR0FBR1U7UUFDckJvQixRQUFRRCxRQUFRLEdBQUduQjtRQUNuQmhDLDBDQUFNQSxDQUFDLENBQUNvRCxRQUFRRyxJQUFJLEVBQUU7SUFDeEIsT0FBTztRQUNMRCxPQUFPUyxHQUFHO0lBQ1o7SUFFQSx1RUFBdUU7SUFDdkUsK0RBQStEO0lBQy9EdkQsUUFBUThDLE9BQU9yQyxNQUFNO0lBRXJCLE1BQU9ULFFBQVM7UUFDZCxNQUFNNkIsUUFBUVcsWUFBWVgsS0FBSyxDQUFDaUIsTUFBTSxDQUFDOUMsTUFBTSxFQUFFOEMsTUFBTSxDQUFDOUMsUUFBUSxFQUFFO1FBQ2hFLE1BQU00QixRQUFRUyxlQUFla0IsR0FBRztRQUNoQy9ELDBDQUFNQSxDQUFDb0MsVUFBVUosV0FBVztRQUM1QnpCLE1BQU1pRCxJQUFJLENBQUM7WUFBQ3BCO1lBQU9BLFFBQVFDLE1BQU1wQixNQUFNLEdBQUc7U0FBRTtRQUM1Q0QsT0FBT2YsTUFBTSxDQUFDbUMsT0FBTyxHQUFHQztJQUMxQjtJQUVBOUIsTUFBTXlELE9BQU87SUFDYnhELFFBQVEsQ0FBQztJQUVULE1BQU8sRUFBRUEsUUFBUUQsTUFBTVUsTUFBTSxDQUFFO1FBQzdCZ0MsSUFBSSxDQUFDSSxTQUFTOUMsS0FBSyxDQUFDQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUc2QyxTQUFTOUMsS0FBSyxDQUFDQyxNQUFNLENBQUMsRUFBRTtRQUN6RDZDLFVBQVU5QyxLQUFLLENBQUNDLE1BQU0sQ0FBQyxFQUFFLEdBQUdELEtBQUssQ0FBQ0MsTUFBTSxDQUFDLEVBQUUsR0FBRztJQUNoRDtJQUVBLE9BQU95QztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0b19mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1zdWJ0b2tlbml6ZS9kZXYvaW5kZXguanM/ZTFjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge0NodW5rLCBFdmVudCwgVG9rZW59IGZyb20gJ21pY3JvbWFyay11dGlsLXR5cGVzJ1xuICovXG5cbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICdkZXZsb3AnXG5pbXBvcnQge3NwbGljZX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2h1bmtlZCdcbmltcG9ydCB7Y29kZXMsIHR5cGVzfSBmcm9tICdtaWNyb21hcmstdXRpbC1zeW1ib2wnXG5pbXBvcnQge1NwbGljZUJ1ZmZlcn0gZnJvbSAnLi9saWIvc3BsaWNlLWJ1ZmZlci5qcydcblxuLy8gSGlkZGVuIEFQSSBleHBvc2VkIGZvciB0ZXN0aW5nLlxuZXhwb3J0IHtTcGxpY2VCdWZmZXJ9IGZyb20gJy4vbGliL3NwbGljZS1idWZmZXIuanMnXG5cbi8qKlxuICogVG9rZW5pemUgc3ViY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PEV2ZW50Pn0gZXZlbnRzQXJyYXlcbiAqICAgTGlzdCBvZiBldmVudHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqICAgV2hldGhlciBzdWJ0b2tlbnMgd2VyZSBmb3VuZC5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBmdW5jdGlvbiBzdWJ0b2tlbml6ZShldmVudHNBcnJheSkge1xuICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIG51bWJlcj59ICovXG4gIGNvbnN0IGp1bXBzID0ge31cbiAgbGV0IGluZGV4ID0gLTFcbiAgLyoqIEB0eXBlIHtFdmVudH0gKi9cbiAgbGV0IGV2ZW50XG4gIC8qKiBAdHlwZSB7bnVtYmVyIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgbGluZUluZGV4XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICBsZXQgb3RoZXJJbmRleFxuICAvKiogQHR5cGUge0V2ZW50fSAqL1xuICBsZXQgb3RoZXJFdmVudFxuICAvKiogQHR5cGUge0FycmF5PEV2ZW50Pn0gKi9cbiAgbGV0IHBhcmFtZXRlcnNcbiAgLyoqIEB0eXBlIHtBcnJheTxFdmVudD59ICovXG4gIGxldCBzdWJldmVudHNcbiAgLyoqIEB0eXBlIHtib29sZWFuIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgbW9yZVxuICBjb25zdCBldmVudHMgPSBuZXcgU3BsaWNlQnVmZmVyKGV2ZW50c0FycmF5KVxuXG4gIHdoaWxlICgrK2luZGV4IDwgZXZlbnRzLmxlbmd0aCkge1xuICAgIHdoaWxlIChpbmRleCBpbiBqdW1wcykge1xuICAgICAgaW5kZXggPSBqdW1wc1tpbmRleF1cbiAgICB9XG5cbiAgICBldmVudCA9IGV2ZW50cy5nZXQoaW5kZXgpXG5cbiAgICAvLyBBZGQgYSBob29rIGZvciB0aGUgR0ZNIHRhc2tsaXN0IGV4dGVuc2lvbiwgd2hpY2ggbmVlZHMgdG8ga25vdyBpZiB0ZXh0XG4gICAgLy8gaXMgaW4gdGhlIGZpcnN0IGNvbnRlbnQgb2YgYSBsaXN0IGl0ZW0uXG4gICAgaWYgKFxuICAgICAgaW5kZXggJiZcbiAgICAgIGV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmNodW5rRmxvdyAmJlxuICAgICAgZXZlbnRzLmdldChpbmRleCAtIDEpWzFdLnR5cGUgPT09IHR5cGVzLmxpc3RJdGVtUHJlZml4XG4gICAgKSB7XG4gICAgICBhc3NlcnQoZXZlbnRbMV0uX3Rva2VuaXplciwgJ2V4cGVjdGVkIGBfdG9rZW5pemVyYCBvbiBzdWJ0b2tlbnMnKVxuICAgICAgc3ViZXZlbnRzID0gZXZlbnRbMV0uX3Rva2VuaXplci5ldmVudHNcbiAgICAgIG90aGVySW5kZXggPSAwXG5cbiAgICAgIGlmIChcbiAgICAgICAgb3RoZXJJbmRleCA8IHN1YmV2ZW50cy5sZW5ndGggJiZcbiAgICAgICAgc3ViZXZlbnRzW290aGVySW5kZXhdWzFdLnR5cGUgPT09IHR5cGVzLmxpbmVFbmRpbmdCbGFua1xuICAgICAgKSB7XG4gICAgICAgIG90aGVySW5kZXggKz0gMlxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIG90aGVySW5kZXggPCBzdWJldmVudHMubGVuZ3RoICYmXG4gICAgICAgIHN1YmV2ZW50c1tvdGhlckluZGV4XVsxXS50eXBlID09PSB0eXBlcy5jb250ZW50XG4gICAgICApIHtcbiAgICAgICAgd2hpbGUgKCsrb3RoZXJJbmRleCA8IHN1YmV2ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoc3ViZXZlbnRzW290aGVySW5kZXhdWzFdLnR5cGUgPT09IHR5cGVzLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN1YmV2ZW50c1tvdGhlckluZGV4XVsxXS50eXBlID09PSB0eXBlcy5jaHVua1RleHQpIHtcbiAgICAgICAgICAgIHN1YmV2ZW50c1tvdGhlckluZGV4XVsxXS5faXNJbkZpcnN0Q29udGVudE9mTGlzdEl0ZW0gPSB0cnVlXG4gICAgICAgICAgICBvdGhlckluZGV4KytcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbnRlci5cbiAgICBpZiAoZXZlbnRbMF0gPT09ICdlbnRlcicpIHtcbiAgICAgIGlmIChldmVudFsxXS5jb250ZW50VHlwZSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGp1bXBzLCBzdWJjb250ZW50KGV2ZW50cywgaW5kZXgpKVxuICAgICAgICBpbmRleCA9IGp1bXBzW2luZGV4XVxuICAgICAgICBtb3JlID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBFeGl0LlxuICAgIGVsc2UgaWYgKGV2ZW50WzFdLl9jb250YWluZXIpIHtcbiAgICAgIG90aGVySW5kZXggPSBpbmRleFxuICAgICAgbGluZUluZGV4ID0gdW5kZWZpbmVkXG5cbiAgICAgIHdoaWxlIChvdGhlckluZGV4LS0pIHtcbiAgICAgICAgb3RoZXJFdmVudCA9IGV2ZW50cy5nZXQob3RoZXJJbmRleClcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgb3RoZXJFdmVudFsxXS50eXBlID09PSB0eXBlcy5saW5lRW5kaW5nIHx8XG4gICAgICAgICAgb3RoZXJFdmVudFsxXS50eXBlID09PSB0eXBlcy5saW5lRW5kaW5nQmxhbmtcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKG90aGVyRXZlbnRbMF0gPT09ICdlbnRlcicpIHtcbiAgICAgICAgICAgIGlmIChsaW5lSW5kZXgpIHtcbiAgICAgICAgICAgICAgZXZlbnRzLmdldChsaW5lSW5kZXgpWzFdLnR5cGUgPSB0eXBlcy5saW5lRW5kaW5nQmxhbmtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3RoZXJFdmVudFsxXS50eXBlID0gdHlwZXMubGluZUVuZGluZ1xuICAgICAgICAgICAgbGluZUluZGV4ID0gb3RoZXJJbmRleFxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvdGhlckV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpbmVQcmVmaXgpIHtcbiAgICAgICAgICAvLyBNb3ZlIHBhc3QuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGluZUluZGV4KSB7XG4gICAgICAgIC8vIEZpeCBwb3NpdGlvbi5cbiAgICAgICAgZXZlbnRbMV0uZW5kID0gey4uLmV2ZW50cy5nZXQobGluZUluZGV4KVsxXS5zdGFydH1cblxuICAgICAgICAvLyBTd2l0Y2ggY29udGFpbmVyIGV4aXQgdy8gbGluZSBlbmRpbmdzLlxuICAgICAgICBwYXJhbWV0ZXJzID0gZXZlbnRzLnNsaWNlKGxpbmVJbmRleCwgaW5kZXgpXG4gICAgICAgIHBhcmFtZXRlcnMudW5zaGlmdChldmVudClcbiAgICAgICAgZXZlbnRzLnNwbGljZShsaW5lSW5kZXgsIGluZGV4IC0gbGluZUluZGV4ICsgMSwgcGFyYW1ldGVycylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUaGUgY2hhbmdlcyB0byB0aGUgYGV2ZW50c2AgYnVmZmVyIG11c3QgYmUgY29waWVkIGJhY2sgaW50byB0aGUgZXZlbnRzQXJyYXlcbiAgc3BsaWNlKGV2ZW50c0FycmF5LCAwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIGV2ZW50cy5zbGljZSgwKSlcbiAgcmV0dXJuICFtb3JlXG59XG5cbi8qKlxuICogVG9rZW5pemUgZW1iZWRkZWQgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSB7U3BsaWNlQnVmZmVyPEV2ZW50Pn0gZXZlbnRzXG4gKiAgIEV2ZW50cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBldmVudEluZGV4XG4gKiAgIEluZGV4LlxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIG51bWJlcj59XG4gKiAgIEdhcHMuXG4gKi9cbmZ1bmN0aW9uIHN1YmNvbnRlbnQoZXZlbnRzLCBldmVudEluZGV4KSB7XG4gIGNvbnN0IHRva2VuID0gZXZlbnRzLmdldChldmVudEluZGV4KVsxXVxuICBjb25zdCBjb250ZXh0ID0gZXZlbnRzLmdldChldmVudEluZGV4KVsyXVxuICBsZXQgc3RhcnRQb3NpdGlvbiA9IGV2ZW50SW5kZXggLSAxXG4gIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgY29uc3Qgc3RhcnRQb3NpdGlvbnMgPSBbXVxuICBhc3NlcnQodG9rZW4uY29udGVudFR5cGUsICdleHBlY3RlZCBgY29udGVudFR5cGVgIG9uIHN1YnRva2VucycpXG4gIGNvbnN0IHRva2VuaXplciA9XG4gICAgdG9rZW4uX3Rva2VuaXplciB8fCBjb250ZXh0LnBhcnNlclt0b2tlbi5jb250ZW50VHlwZV0odG9rZW4uc3RhcnQpXG4gIGNvbnN0IGNoaWxkRXZlbnRzID0gdG9rZW5pemVyLmV2ZW50c1xuICAvKiogQHR5cGUge0FycmF5PFtudW1iZXIsIG51bWJlcl0+fSAqL1xuICBjb25zdCBqdW1wcyA9IFtdXG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgbnVtYmVyPn0gKi9cbiAgY29uc3QgZ2FwcyA9IHt9XG4gIC8qKiBAdHlwZSB7QXJyYXk8Q2h1bms+fSAqL1xuICBsZXQgc3RyZWFtXG4gIC8qKiBAdHlwZSB7VG9rZW4gfCB1bmRlZmluZWR9ICovXG4gIGxldCBwcmV2aW91c1xuICBsZXQgaW5kZXggPSAtMVxuICAvKiogQHR5cGUge1Rva2VuIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgY3VycmVudCA9IHRva2VuXG4gIGxldCBhZGp1c3QgPSAwXG4gIGxldCBzdGFydCA9IDBcbiAgY29uc3QgYnJlYWtzID0gW3N0YXJ0XVxuXG4gIC8vIExvb3AgZm9yd2FyZCB0aHJvdWdoIHRoZSBsaW5rZWQgdG9rZW5zIHRvIHBhc3MgdGhlbSBpbiBvcmRlciB0byB0aGVcbiAgLy8gc3VidG9rZW5pemVyLlxuICB3aGlsZSAoY3VycmVudCkge1xuICAgIC8vIEZpbmQgdGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCBmb3IgdGhpcyB0b2tlbi5cbiAgICB3aGlsZSAoZXZlbnRzLmdldCgrK3N0YXJ0UG9zaXRpb24pWzFdICE9PSBjdXJyZW50KSB7XG4gICAgICAvLyBFbXB0eS5cbiAgICB9XG5cbiAgICBhc3NlcnQoXG4gICAgICAhcHJldmlvdXMgfHwgY3VycmVudC5wcmV2aW91cyA9PT0gcHJldmlvdXMsXG4gICAgICAnZXhwZWN0ZWQgcHJldmlvdXMgdG8gbWF0Y2gnXG4gICAgKVxuICAgIGFzc2VydCghcHJldmlvdXMgfHwgcHJldmlvdXMubmV4dCA9PT0gY3VycmVudCwgJ2V4cGVjdGVkIG5leHQgdG8gbWF0Y2gnKVxuXG4gICAgc3RhcnRQb3NpdGlvbnMucHVzaChzdGFydFBvc2l0aW9uKVxuXG4gICAgaWYgKCFjdXJyZW50Ll90b2tlbml6ZXIpIHtcbiAgICAgIHN0cmVhbSA9IGNvbnRleHQuc2xpY2VTdHJlYW0oY3VycmVudClcblxuICAgICAgaWYgKCFjdXJyZW50Lm5leHQpIHtcbiAgICAgICAgc3RyZWFtLnB1c2goY29kZXMuZW9mKVxuICAgICAgfVxuXG4gICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgdG9rZW5pemVyLmRlZmluZVNraXAoY3VycmVudC5zdGFydClcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnQuX2lzSW5GaXJzdENvbnRlbnRPZkxpc3RJdGVtKSB7XG4gICAgICAgIHRva2VuaXplci5fZ2ZtVGFza2xpc3RGaXJzdENvbnRlbnRPZkxpc3RJdGVtID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICB0b2tlbml6ZXIud3JpdGUoc3RyZWFtKVxuXG4gICAgICBpZiAoY3VycmVudC5faXNJbkZpcnN0Q29udGVudE9mTGlzdEl0ZW0pIHtcbiAgICAgICAgdG9rZW5pemVyLl9nZm1UYXNrbGlzdEZpcnN0Q29udGVudE9mTGlzdEl0ZW0gPSB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVbnJhdmVsIHRoZSBuZXh0IHRva2VuLlxuICAgIHByZXZpb3VzID0gY3VycmVudFxuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHRcbiAgfVxuXG4gIC8vIE5vdywgbG9vcCBiYWNrIHRocm91Z2ggYWxsIGV2ZW50cyAoYW5kIGxpbmtlZCB0b2tlbnMpLCB0byBmaWd1cmUgb3V0IHdoaWNoXG4gIC8vIHBhcnRzIGJlbG9uZyB3aGVyZS5cbiAgY3VycmVudCA9IHRva2VuXG5cbiAgd2hpbGUgKCsraW5kZXggPCBjaGlsZEV2ZW50cy5sZW5ndGgpIHtcbiAgICBpZiAoXG4gICAgICAvLyBGaW5kIGEgdm9pZCB0b2tlbiB0aGF0IGluY2x1ZGVzIGEgYnJlYWsuXG4gICAgICBjaGlsZEV2ZW50c1tpbmRleF1bMF0gPT09ICdleGl0JyAmJlxuICAgICAgY2hpbGRFdmVudHNbaW5kZXggLSAxXVswXSA9PT0gJ2VudGVyJyAmJlxuICAgICAgY2hpbGRFdmVudHNbaW5kZXhdWzFdLnR5cGUgPT09IGNoaWxkRXZlbnRzW2luZGV4IC0gMV1bMV0udHlwZSAmJlxuICAgICAgY2hpbGRFdmVudHNbaW5kZXhdWzFdLnN0YXJ0LmxpbmUgIT09IGNoaWxkRXZlbnRzW2luZGV4XVsxXS5lbmQubGluZVxuICAgICkge1xuICAgICAgYXNzZXJ0KGN1cnJlbnQsICdleHBlY3RlZCBhIGN1cnJlbnQgdG9rZW4nKVxuICAgICAgc3RhcnQgPSBpbmRleCArIDFcbiAgICAgIGJyZWFrcy5wdXNoKHN0YXJ0KVxuICAgICAgLy8gSGVscCBHQy5cbiAgICAgIGN1cnJlbnQuX3Rva2VuaXplciA9IHVuZGVmaW5lZFxuICAgICAgY3VycmVudC5wcmV2aW91cyA9IHVuZGVmaW5lZFxuICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dFxuICAgIH1cbiAgfVxuXG4gIC8vIEhlbHAgR0MuXG4gIHRva2VuaXplci5ldmVudHMgPSBbXVxuXG4gIC8vIElmIHRoZXJl4oCZcyBvbmUgbW9yZSB0b2tlbiAod2hpY2ggaXMgdGhlIGNhc2VzIGZvciBsaW5lcyB0aGF0IGVuZCBpbiBhblxuICAvLyBFT0YpLCB0aGF04oCZcyBwZXJmZWN0OiB0aGUgbGFzdCBwb2ludCB3ZSBmb3VuZCBzdGFydHMgaXQuXG4gIC8vIElmIHRoZXJlIGlzbuKAmXQgdGhlbiBtYWtlIHN1cmUgYW55IHJlbWFpbmluZyBjb250ZW50IGlzIGFkZGVkIHRvIGl0LlxuICBpZiAoY3VycmVudCkge1xuICAgIC8vIEhlbHAgR0MuXG4gICAgY3VycmVudC5fdG9rZW5pemVyID0gdW5kZWZpbmVkXG4gICAgY3VycmVudC5wcmV2aW91cyA9IHVuZGVmaW5lZFxuICAgIGFzc2VydCghY3VycmVudC5uZXh0LCAnZXhwZWN0ZWQgbm8gbmV4dCB0b2tlbicpXG4gIH0gZWxzZSB7XG4gICAgYnJlYWtzLnBvcCgpXG4gIH1cblxuICAvLyBOb3cgc3BsaWNlIHRoZSBldmVudHMgZnJvbSB0aGUgc3VidG9rZW5pemVyIGludG8gdGhlIGN1cnJlbnQgZXZlbnRzLFxuICAvLyBtb3ZpbmcgYmFjayB0byBmcm9udCBzbyB0aGF0IHNwbGljZSBpbmRpY2VzIGFyZW7igJl0IGFmZmVjdGVkLlxuICBpbmRleCA9IGJyZWFrcy5sZW5ndGhcblxuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIGNvbnN0IHNsaWNlID0gY2hpbGRFdmVudHMuc2xpY2UoYnJlYWtzW2luZGV4XSwgYnJlYWtzW2luZGV4ICsgMV0pXG4gICAgY29uc3Qgc3RhcnQgPSBzdGFydFBvc2l0aW9ucy5wb3AoKVxuICAgIGFzc2VydChzdGFydCAhPT0gdW5kZWZpbmVkLCAnZXhwZWN0ZWQgYSBzdGFydCBwb3NpdGlvbiB3aGVuIHNwbGljaW5nJylcbiAgICBqdW1wcy5wdXNoKFtzdGFydCwgc3RhcnQgKyBzbGljZS5sZW5ndGggLSAxXSlcbiAgICBldmVudHMuc3BsaWNlKHN0YXJ0LCAyLCBzbGljZSlcbiAgfVxuXG4gIGp1bXBzLnJldmVyc2UoKVxuICBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCBqdW1wcy5sZW5ndGgpIHtcbiAgICBnYXBzW2FkanVzdCArIGp1bXBzW2luZGV4XVswXV0gPSBhZGp1c3QgKyBqdW1wc1tpbmRleF1bMV1cbiAgICBhZGp1c3QgKz0ganVtcHNbaW5kZXhdWzFdIC0ganVtcHNbaW5kZXhdWzBdIC0gMVxuICB9XG5cbiAgcmV0dXJuIGdhcHNcbn1cbiJdLCJuYW1lcyI6WyJvayIsImFzc2VydCIsInNwbGljZSIsImNvZGVzIiwidHlwZXMiLCJTcGxpY2VCdWZmZXIiLCJzdWJ0b2tlbml6ZSIsImV2ZW50c0FycmF5IiwianVtcHMiLCJpbmRleCIsImV2ZW50IiwibGluZUluZGV4Iiwib3RoZXJJbmRleCIsIm90aGVyRXZlbnQiLCJwYXJhbWV0ZXJzIiwic3ViZXZlbnRzIiwibW9yZSIsImV2ZW50cyIsImxlbmd0aCIsImdldCIsInR5cGUiLCJjaHVua0Zsb3ciLCJsaXN0SXRlbVByZWZpeCIsIl90b2tlbml6ZXIiLCJsaW5lRW5kaW5nQmxhbmsiLCJjb250ZW50IiwiY2h1bmtUZXh0IiwiX2lzSW5GaXJzdENvbnRlbnRPZkxpc3RJdGVtIiwiY29udGVudFR5cGUiLCJPYmplY3QiLCJhc3NpZ24iLCJzdWJjb250ZW50IiwiX2NvbnRhaW5lciIsInVuZGVmaW5lZCIsImxpbmVFbmRpbmciLCJsaW5lUHJlZml4IiwiZW5kIiwic3RhcnQiLCJzbGljZSIsInVuc2hpZnQiLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsImV2ZW50SW5kZXgiLCJ0b2tlbiIsImNvbnRleHQiLCJzdGFydFBvc2l0aW9uIiwic3RhcnRQb3NpdGlvbnMiLCJ0b2tlbml6ZXIiLCJwYXJzZXIiLCJjaGlsZEV2ZW50cyIsImdhcHMiLCJzdHJlYW0iLCJwcmV2aW91cyIsImN1cnJlbnQiLCJhZGp1c3QiLCJicmVha3MiLCJuZXh0IiwicHVzaCIsInNsaWNlU3RyZWFtIiwiZW9mIiwiZGVmaW5lU2tpcCIsIl9nZm1UYXNrbGlzdEZpcnN0Q29udGVudE9mTGlzdEl0ZW0iLCJ3cml0ZSIsImxpbmUiLCJwb3AiLCJyZXZlcnNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micromark-util-subtokenize/dev/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/micromark-util-subtokenize/dev/lib/splice-buffer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/micromark-util-subtokenize/dev/lib/splice-buffer.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SpliceBuffer: () => (/* binding */ SpliceBuffer)\n/* harmony export */ });\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/micromark-util-symbol/lib/constants.js\");\n\n/**\n * Some of the internal operations of micromark do lots of editing\n * operations on very large arrays. This runs into problems with two\n * properties of most circa-2020 JavaScript interpreters:\n *\n *  - Array-length modifications at the high end of an array (push/pop) are\n *    expected to be common and are implemented in (amortized) time\n *    proportional to the number of elements added or removed, whereas\n *    other operations (shift/unshift and splice) are much less efficient.\n *  - Function arguments are passed on the stack, so adding tens of thousands\n *    of elements to an array with `arr.push(...newElements)` will frequently\n *    cause stack overflows. (see <https://stackoverflow.com/questions/22123769/rangeerror-maximum-call-stack-size-exceeded-why>)\n *\n * SpliceBuffers are an implementation of gap buffers, which are a\n * generalization of the \"queue made of two stacks\" idea. The splice buffer\n * maintains a cursor, and moving the cursor has cost proportional to the\n * distance the cursor moves, but inserting, deleting, or splicing in\n * new information at the cursor is as efficient as the push/pop operation.\n * This allows for an efficient sequence of splices (or pushes, pops, shifts,\n * or unshifts) as long such edits happen at the same part of the array or\n * generally sweep through the array from the beginning to the end.\n *\n * The interface for splice buffers also supports large numbers of inputs by\n * passing a single array argument rather passing multiple arguments on the\n * function call stack.\n *\n * @template T\n *   Item type.\n */ class SpliceBuffer {\n    /**\n   * @param {ReadonlyArray<T> | null | undefined} [initial]\n   *   Initial items (optional).\n   * @returns\n   *   Splice buffer.\n   */ constructor(initial){\n        /** @type {Array<T>} */ this.left = initial ? [\n            ...initial\n        ] : [];\n        /** @type {Array<T>} */ this.right = [];\n    }\n    /**\n   * Array access;\n   * does not move the cursor.\n   *\n   * @param {number} index\n   *   Index.\n   * @return {T}\n   *   Item.\n   */ get(index) {\n        if (index < 0 || index >= this.left.length + this.right.length) {\n            throw new RangeError(\"Cannot access index `\" + index + \"` in a splice buffer of size `\" + (this.left.length + this.right.length) + \"`\");\n        }\n        if (index < this.left.length) return this.left[index];\n        return this.right[this.right.length - index + this.left.length - 1];\n    }\n    /**\n   * The length of the splice buffer, one greater than the largest index in the\n   * array.\n   */ get length() {\n        return this.left.length + this.right.length;\n    }\n    /**\n   * Remove and return `list[0]`;\n   * moves the cursor to `0`.\n   *\n   * @returns {T | undefined}\n   *   Item, optional.\n   */ shift() {\n        this.setCursor(0);\n        return this.right.pop();\n    }\n    /**\n   * Slice the buffer to get an array;\n   * does not move the cursor.\n   *\n   * @param {number} start\n   *   Start.\n   * @param {number | null | undefined} [end]\n   *   End (optional).\n   * @returns {Array<T>}\n   *   Array of items.\n   */ slice(start, end) {\n        /** @type {number} */ const stop = end === null || end === undefined ? Number.POSITIVE_INFINITY : end;\n        if (stop < this.left.length) {\n            return this.left.slice(start, stop);\n        }\n        if (start > this.left.length) {\n            return this.right.slice(this.right.length - stop + this.left.length, this.right.length - start + this.left.length).reverse();\n        }\n        return this.left.slice(start).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());\n    }\n    /**\n   * Mimics the behavior of Array.prototype.splice() except for the change of\n   * interface necessary to avoid segfaults when patching in very large arrays.\n   *\n   * This operation moves cursor is moved to `start` and results in the cursor\n   * placed after any inserted items.\n   *\n   * @param {number} start\n   *   Start;\n   *   zero-based index at which to start changing the array;\n   *   negative numbers count backwards from the end of the array and values\n   *   that are out-of bounds are clamped to the appropriate end of the array.\n   * @param {number | null | undefined} [deleteCount=0]\n   *   Delete count (default: `0`);\n   *   maximum number of elements to delete, starting from start.\n   * @param {Array<T> | null | undefined} [items=[]]\n   *   Items to include in place of the deleted items (default: `[]`).\n   * @return {Array<T>}\n   *   Any removed items.\n   */ splice(start, deleteCount, items) {\n        /** @type {number} */ const count = deleteCount || 0;\n        this.setCursor(Math.trunc(start));\n        const removed = this.right.splice(this.right.length - count, Number.POSITIVE_INFINITY);\n        if (items) chunkedPush(this.left, items);\n        return removed.reverse();\n    }\n    /**\n   * Remove and return the highest-numbered item in the array, so\n   * `list[list.length - 1]`;\n   * Moves the cursor to `length`.\n   *\n   * @returns {T | undefined}\n   *   Item, optional.\n   */ pop() {\n        this.setCursor(Number.POSITIVE_INFINITY);\n        return this.left.pop();\n    }\n    /**\n   * Inserts a single item to the high-numbered side of the array;\n   * moves the cursor to `length`.\n   *\n   * @param {T} item\n   *   Item.\n   * @returns {undefined}\n   *   Nothing.\n   */ push(item) {\n        this.setCursor(Number.POSITIVE_INFINITY);\n        this.left.push(item);\n    }\n    /**\n   * Inserts many items to the high-numbered side of the array.\n   * Moves the cursor to `length`.\n   *\n   * @param {Array<T>} items\n   *   Items.\n   * @returns {undefined}\n   *   Nothing.\n   */ pushMany(items) {\n        this.setCursor(Number.POSITIVE_INFINITY);\n        chunkedPush(this.left, items);\n    }\n    /**\n   * Inserts a single item to the low-numbered side of the array;\n   * Moves the cursor to `0`.\n   *\n   * @param {T} item\n   *   Item.\n   * @returns {undefined}\n   *   Nothing.\n   */ unshift(item) {\n        this.setCursor(0);\n        this.right.push(item);\n    }\n    /**\n   * Inserts many items to the low-numbered side of the array;\n   * moves the cursor to `0`.\n   *\n   * @param {Array<T>} items\n   *   Items.\n   * @returns {undefined}\n   *   Nothing.\n   */ unshiftMany(items) {\n        this.setCursor(0);\n        chunkedPush(this.right, items.reverse());\n    }\n    /**\n   * Move the cursor to a specific position in the array. Requires\n   * time proportional to the distance moved.\n   *\n   * If `n < 0`, the cursor will end up at the beginning.\n   * If `n > length`, the cursor will end up at the end.\n   *\n   * @param {number} n\n   *   Position.\n   * @return {undefined}\n   *   Nothing.\n   */ setCursor(n) {\n        if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0) return;\n        if (n < this.left.length) {\n            // Move cursor to the this.left\n            const removed = this.left.splice(n, Number.POSITIVE_INFINITY);\n            chunkedPush(this.right, removed.reverse());\n        } else {\n            // Move cursor to the this.right\n            const removed = this.right.splice(this.left.length + this.right.length - n, Number.POSITIVE_INFINITY);\n            chunkedPush(this.left, removed.reverse());\n        }\n    }\n}\n/**\n * Avoid stack overflow by pushing items onto the stack in segments\n *\n * @template T\n *   Item type.\n * @param {Array<T>} list\n *   List to inject into.\n * @param {ReadonlyArray<T>} right\n *   Items to inject.\n * @return {undefined}\n *   Nothing.\n */ function chunkedPush(list, right) {\n    /** @type {number} */ let chunkStart = 0;\n    if (right.length < micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.constants.v8MaxSafeChunkSize) {\n        list.push(...right);\n    } else {\n        while(chunkStart < right.length){\n            list.push(...right.slice(chunkStart, chunkStart + micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.constants.v8MaxSafeChunkSize));\n            chunkStart += micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.constants.v8MaxSafeChunkSize;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLXV0aWwtc3VidG9rZW5pemUvZGV2L2xpYi9zcGxpY2UtYnVmZmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStDO0FBRS9DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNEJDLEdBQ00sTUFBTUM7SUFDWDs7Ozs7R0FLQyxHQUNEQyxZQUFZQyxPQUFPLENBQUU7UUFDbkIscUJBQXFCLEdBQ3JCLElBQUksQ0FBQ0MsSUFBSSxHQUFHRCxVQUFVO2VBQUlBO1NBQVEsR0FBRyxFQUFFO1FBQ3ZDLHFCQUFxQixHQUNyQixJQUFJLENBQUNFLEtBQUssR0FBRyxFQUFFO0lBQ2pCO0lBRUE7Ozs7Ozs7O0dBUUMsR0FDREMsSUFBSUMsS0FBSyxFQUFFO1FBQ1QsSUFBSUEsUUFBUSxLQUFLQSxTQUFTLElBQUksQ0FBQ0gsSUFBSSxDQUFDSSxNQUFNLEdBQUcsSUFBSSxDQUFDSCxLQUFLLENBQUNHLE1BQU0sRUFBRTtZQUM5RCxNQUFNLElBQUlDLFdBQ1IsMEJBQ0VGLFFBQ0EsbUNBQ0MsS0FBSSxDQUFDSCxJQUFJLENBQUNJLE1BQU0sR0FBRyxJQUFJLENBQUNILEtBQUssQ0FBQ0csTUFBTSxJQUNyQztRQUVOO1FBRUEsSUFBSUQsUUFBUSxJQUFJLENBQUNILElBQUksQ0FBQ0ksTUFBTSxFQUFFLE9BQU8sSUFBSSxDQUFDSixJQUFJLENBQUNHLE1BQU07UUFDckQsT0FBTyxJQUFJLENBQUNGLEtBQUssQ0FBQyxJQUFJLENBQUNBLEtBQUssQ0FBQ0csTUFBTSxHQUFHRCxRQUFRLElBQUksQ0FBQ0gsSUFBSSxDQUFDSSxNQUFNLEdBQUcsRUFBRTtJQUNyRTtJQUVBOzs7R0FHQyxHQUNELElBQUlBLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQ0osSUFBSSxDQUFDSSxNQUFNLEdBQUcsSUFBSSxDQUFDSCxLQUFLLENBQUNHLE1BQU07SUFDN0M7SUFFQTs7Ozs7O0dBTUMsR0FDREUsUUFBUTtRQUNOLElBQUksQ0FBQ0Ms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LElBQUksS0FBSyxJQUFJLENBQUMvQixJQUFJLENBQUNJLE1BQU0sS0FBSyxHQUUvQjtRQUNGLElBQUkyQixJQUFJLElBQUksQ0FBQy9CLElBQUksQ0FBQ0ksTUFBTSxFQUFFO1lBQ3hCLCtCQUErQjtZQUMvQixNQUFNb0IsVUFBVSxJQUFJLENBQUN4QixJQUFJLENBQUNrQixNQUFNLENBQUNhLEdBQUdqQixPQUFPQyxpQkFBaUI7WUFDNURVLFlBQVksSUFBSSxDQUFDeEIsS0FBSyxFQUFFdUIsUUFBUVIsT0FBTztRQUN6QyxPQUFPO1lBQ0wsZ0NBQWdDO1lBQ2hDLE1BQU1RLFVBQVUsSUFBSSxDQUFDdkIsS0FBSyxDQUFDaUIsTUFBTSxDQUMvQixJQUFJLENBQUNsQixJQUFJLENBQUNJLE1BQU0sR0FBRyxJQUFJLENBQUNILEtBQUssQ0FBQ0csTUFBTSxHQUFHMkIsR0FDdkNqQixPQUFPQyxpQkFBaUI7WUFFMUJVLFlBQVksSUFBSSxDQUFDekIsSUFBSSxFQUFFd0IsUUFBUVIsT0FBTztRQUN4QztJQUNGO0FBQ0Y7QUFFQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELFNBQVNTLFlBQVlPLElBQUksRUFBRS9CLEtBQUs7SUFDOUIsbUJBQW1CLEdBQ25CLElBQUlnQyxhQUFhO0lBRWpCLElBQUloQyxNQUFNRyxNQUFNLEdBQUdSLDREQUFTQSxDQUFDc0Msa0JBQWtCLEVBQUU7UUFDL0NGLEtBQUtOLElBQUksSUFBSXpCO0lBQ2YsT0FBTztRQUNMLE1BQU9nQyxhQUFhaEMsTUFBTUcsTUFBTSxDQUFFO1lBQ2hDNEIsS0FBS04sSUFBSSxJQUNKekIsTUFBTVEsS0FBSyxDQUFDd0IsWUFBWUEsYUFBYXJDLDREQUFTQSxDQUFDc0Msa0JBQWtCO1lBRXRFRCxjQUFjckMsNERBQVNBLENBQUNzQyxrQkFBa0I7UUFDNUM7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0b19mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1zdWJ0b2tlbml6ZS9kZXYvbGliL3NwbGljZS1idWZmZXIuanM/YTAyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2NvbnN0YW50c30gZnJvbSAnbWljcm9tYXJrLXV0aWwtc3ltYm9sJ1xuXG4vKipcbiAqIFNvbWUgb2YgdGhlIGludGVybmFsIG9wZXJhdGlvbnMgb2YgbWljcm9tYXJrIGRvIGxvdHMgb2YgZWRpdGluZ1xuICogb3BlcmF0aW9ucyBvbiB2ZXJ5IGxhcmdlIGFycmF5cy4gVGhpcyBydW5zIGludG8gcHJvYmxlbXMgd2l0aCB0d29cbiAqIHByb3BlcnRpZXMgb2YgbW9zdCBjaXJjYS0yMDIwIEphdmFTY3JpcHQgaW50ZXJwcmV0ZXJzOlxuICpcbiAqICAtIEFycmF5LWxlbmd0aCBtb2RpZmljYXRpb25zIGF0IHRoZSBoaWdoIGVuZCBvZiBhbiBhcnJheSAocHVzaC9wb3ApIGFyZVxuICogICAgZXhwZWN0ZWQgdG8gYmUgY29tbW9uIGFuZCBhcmUgaW1wbGVtZW50ZWQgaW4gKGFtb3J0aXplZCkgdGltZVxuICogICAgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgYWRkZWQgb3IgcmVtb3ZlZCwgd2hlcmVhc1xuICogICAgb3RoZXIgb3BlcmF0aW9ucyAoc2hpZnQvdW5zaGlmdCBhbmQgc3BsaWNlKSBhcmUgbXVjaCBsZXNzIGVmZmljaWVudC5cbiAqICAtIEZ1bmN0aW9uIGFyZ3VtZW50cyBhcmUgcGFzc2VkIG9uIHRoZSBzdGFjaywgc28gYWRkaW5nIHRlbnMgb2YgdGhvdXNhbmRzXG4gKiAgICBvZiBlbGVtZW50cyB0byBhbiBhcnJheSB3aXRoIGBhcnIucHVzaCguLi5uZXdFbGVtZW50cylgIHdpbGwgZnJlcXVlbnRseVxuICogICAgY2F1c2Ugc3RhY2sgb3ZlcmZsb3dzLiAoc2VlIDxodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMjEyMzc2OS9yYW5nZWVycm9yLW1heGltdW0tY2FsbC1zdGFjay1zaXplLWV4Y2VlZGVkLXdoeT4pXG4gKlxuICogU3BsaWNlQnVmZmVycyBhcmUgYW4gaW1wbGVtZW50YXRpb24gb2YgZ2FwIGJ1ZmZlcnMsIHdoaWNoIGFyZSBhXG4gKiBnZW5lcmFsaXphdGlvbiBvZiB0aGUgXCJxdWV1ZSBtYWRlIG9mIHR3byBzdGFja3NcIiBpZGVhLiBUaGUgc3BsaWNlIGJ1ZmZlclxuICogbWFpbnRhaW5zIGEgY3Vyc29yLCBhbmQgbW92aW5nIHRoZSBjdXJzb3IgaGFzIGNvc3QgcHJvcG9ydGlvbmFsIHRvIHRoZVxuICogZGlzdGFuY2UgdGhlIGN1cnNvciBtb3ZlcywgYnV0IGluc2VydGluZywgZGVsZXRpbmcsIG9yIHNwbGljaW5nIGluXG4gKiBuZXcgaW5mb3JtYXRpb24gYXQgdGhlIGN1cnNvciBpcyBhcyBlZmZpY2llbnQgYXMgdGhlIHB1c2gvcG9wIG9wZXJhdGlvbi5cbiAqIFRoaXMgYWxsb3dzIGZvciBhbiBlZmZpY2llbnQgc2VxdWVuY2Ugb2Ygc3BsaWNlcyAob3IgcHVzaGVzLCBwb3BzLCBzaGlmdHMsXG4gKiBvciB1bnNoaWZ0cykgYXMgbG9uZyBzdWNoIGVkaXRzIGhhcHBlbiBhdCB0aGUgc2FtZSBwYXJ0IG9mIHRoZSBhcnJheSBvclxuICogZ2VuZXJhbGx5IHN3ZWVwIHRocm91Z2ggdGhlIGFycmF5IGZyb20gdGhlIGJlZ2lubmluZyB0byB0aGUgZW5kLlxuICpcbiAqIFRoZSBpbnRlcmZhY2UgZm9yIHNwbGljZSBidWZmZXJzIGFsc28gc3VwcG9ydHMgbGFyZ2UgbnVtYmVycyBvZiBpbnB1dHMgYnlcbiAqIHBhc3NpbmcgYSBzaW5nbGUgYXJyYXkgYXJndW1lbnQgcmF0aGVyIHBhc3NpbmcgbXVsdGlwbGUgYXJndW1lbnRzIG9uIHRoZVxuICogZnVuY3Rpb24gY2FsbCBzdGFjay5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogICBJdGVtIHR5cGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBTcGxpY2VCdWZmZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtSZWFkb25seUFycmF5PFQ+IHwgbnVsbCB8IHVuZGVmaW5lZH0gW2luaXRpYWxdXG4gICAqICAgSW5pdGlhbCBpdGVtcyAob3B0aW9uYWwpLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgIFNwbGljZSBidWZmZXIuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsKSB7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxUPn0gKi9cbiAgICB0aGlzLmxlZnQgPSBpbml0aWFsID8gWy4uLmluaXRpYWxdIDogW11cbiAgICAvKiogQHR5cGUge0FycmF5PFQ+fSAqL1xuICAgIHRoaXMucmlnaHQgPSBbXVxuICB9XG5cbiAgLyoqXG4gICAqIEFycmF5IGFjY2VzcztcbiAgICogZG9lcyBub3QgbW92ZSB0aGUgY3Vyc29yLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogICBJbmRleC5cbiAgICogQHJldHVybiB7VH1cbiAgICogICBJdGVtLlxuICAgKi9cbiAgZ2V0KGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5yaWdodC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgICAnQ2Fubm90IGFjY2VzcyBpbmRleCBgJyArXG4gICAgICAgICAgaW5kZXggK1xuICAgICAgICAgICdgIGluIGEgc3BsaWNlIGJ1ZmZlciBvZiBzaXplIGAnICtcbiAgICAgICAgICAodGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMucmlnaHQubGVuZ3RoKSArXG4gICAgICAgICAgJ2AnXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKGluZGV4IDwgdGhpcy5sZWZ0Lmxlbmd0aCkgcmV0dXJuIHRoaXMubGVmdFtpbmRleF1cbiAgICByZXR1cm4gdGhpcy5yaWdodFt0aGlzLnJpZ2h0Lmxlbmd0aCAtIGluZGV4ICsgdGhpcy5sZWZ0Lmxlbmd0aCAtIDFdXG4gIH1cblxuICAvKipcbiAgICogVGhlIGxlbmd0aCBvZiB0aGUgc3BsaWNlIGJ1ZmZlciwgb25lIGdyZWF0ZXIgdGhhbiB0aGUgbGFyZ2VzdCBpbmRleCBpbiB0aGVcbiAgICogYXJyYXkuXG4gICAqL1xuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5yaWdodC5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW5kIHJldHVybiBgbGlzdFswXWA7XG4gICAqIG1vdmVzIHRoZSBjdXJzb3IgdG8gYDBgLlxuICAgKlxuICAgKiBAcmV0dXJucyB7VCB8IHVuZGVmaW5lZH1cbiAgICogICBJdGVtLCBvcHRpb25hbC5cbiAgICovXG4gIHNoaWZ0KCkge1xuICAgIHRoaXMuc2V0Q3Vyc29yKDApXG4gICAgcmV0dXJuIHRoaXMucmlnaHQucG9wKClcbiAgfVxuXG4gIC8qKlxuICAgKiBTbGljZSB0aGUgYnVmZmVyIHRvIGdldCBhbiBhcnJheTtcbiAgICogZG9lcyBub3QgbW92ZSB0aGUgY3Vyc29yLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICogICBTdGFydC5cbiAgICogQHBhcmFtIHtudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSBbZW5kXVxuICAgKiAgIEVuZCAob3B0aW9uYWwpLlxuICAgKiBAcmV0dXJucyB7QXJyYXk8VD59XG4gICAqICAgQXJyYXkgb2YgaXRlbXMuXG4gICAqL1xuICBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgY29uc3Qgc3RvcCA9XG4gICAgICBlbmQgPT09IG51bGwgfHwgZW5kID09PSB1bmRlZmluZWQgPyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgOiBlbmRcblxuICAgIGlmIChzdG9wIDwgdGhpcy5sZWZ0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVmdC5zbGljZShzdGFydCwgc3RvcClcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiB0aGlzLmxlZnQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yaWdodFxuICAgICAgICAuc2xpY2UoXG4gICAgICAgICAgdGhpcy5yaWdodC5sZW5ndGggLSBzdG9wICsgdGhpcy5sZWZ0Lmxlbmd0aCxcbiAgICAgICAgICB0aGlzLnJpZ2h0Lmxlbmd0aCAtIHN0YXJ0ICsgdGhpcy5sZWZ0Lmxlbmd0aFxuICAgICAgICApXG4gICAgICAgIC5yZXZlcnNlKClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5sZWZ0XG4gICAgICAuc2xpY2Uoc3RhcnQpXG4gICAgICAuY29uY2F0KFxuICAgICAgICB0aGlzLnJpZ2h0LnNsaWNlKHRoaXMucmlnaHQubGVuZ3RoIC0gc3RvcCArIHRoaXMubGVmdC5sZW5ndGgpLnJldmVyc2UoKVxuICAgICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIE1pbWljcyB0aGUgYmVoYXZpb3Igb2YgQXJyYXkucHJvdG90eXBlLnNwbGljZSgpIGV4Y2VwdCBmb3IgdGhlIGNoYW5nZSBvZlxuICAgKiBpbnRlcmZhY2UgbmVjZXNzYXJ5IHRvIGF2b2lkIHNlZ2ZhdWx0cyB3aGVuIHBhdGNoaW5nIGluIHZlcnkgbGFyZ2UgYXJyYXlzLlxuICAgKlxuICAgKiBUaGlzIG9wZXJhdGlvbiBtb3ZlcyBjdXJzb3IgaXMgbW92ZWQgdG8gYHN0YXJ0YCBhbmQgcmVzdWx0cyBpbiB0aGUgY3Vyc29yXG4gICAqIHBsYWNlZCBhZnRlciBhbnkgaW5zZXJ0ZWQgaXRlbXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICAgKiAgIFN0YXJ0O1xuICAgKiAgIHplcm8tYmFzZWQgaW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgY2hhbmdpbmcgdGhlIGFycmF5O1xuICAgKiAgIG5lZ2F0aXZlIG51bWJlcnMgY291bnQgYmFja3dhcmRzIGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkgYW5kIHZhbHVlc1xuICAgKiAgIHRoYXQgYXJlIG91dC1vZiBib3VuZHMgYXJlIGNsYW1wZWQgdG8gdGhlIGFwcHJvcHJpYXRlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2RlbGV0ZUNvdW50PTBdXG4gICAqICAgRGVsZXRlIGNvdW50IChkZWZhdWx0OiBgMGApO1xuICAgKiAgIG1heGltdW0gbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRlbGV0ZSwgc3RhcnRpbmcgZnJvbSBzdGFydC5cbiAgICogQHBhcmFtIHtBcnJheTxUPiB8IG51bGwgfCB1bmRlZmluZWR9IFtpdGVtcz1bXV1cbiAgICogICBJdGVtcyB0byBpbmNsdWRlIGluIHBsYWNlIG9mIHRoZSBkZWxldGVkIGl0ZW1zIChkZWZhdWx0OiBgW11gKS5cbiAgICogQHJldHVybiB7QXJyYXk8VD59XG4gICAqICAgQW55IHJlbW92ZWQgaXRlbXMuXG4gICAqL1xuICBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50LCBpdGVtcykge1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIGNvbnN0IGNvdW50ID0gZGVsZXRlQ291bnQgfHwgMFxuXG4gICAgdGhpcy5zZXRDdXJzb3IoTWF0aC50cnVuYyhzdGFydCkpXG4gICAgY29uc3QgcmVtb3ZlZCA9IHRoaXMucmlnaHQuc3BsaWNlKFxuICAgICAgdGhpcy5yaWdodC5sZW5ndGggLSBjb3VudCxcbiAgICAgIE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICAgIClcbiAgICBpZiAoaXRlbXMpIGNodW5rZWRQdXNoKHRoaXMubGVmdCwgaXRlbXMpXG4gICAgcmV0dXJuIHJlbW92ZWQucmV2ZXJzZSgpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuZCByZXR1cm4gdGhlIGhpZ2hlc3QtbnVtYmVyZWQgaXRlbSBpbiB0aGUgYXJyYXksIHNvXG4gICAqIGBsaXN0W2xpc3QubGVuZ3RoIC0gMV1gO1xuICAgKiBNb3ZlcyB0aGUgY3Vyc29yIHRvIGBsZW5ndGhgLlxuICAgKlxuICAgKiBAcmV0dXJucyB7VCB8IHVuZGVmaW5lZH1cbiAgICogICBJdGVtLCBvcHRpb25hbC5cbiAgICovXG4gIHBvcCgpIHtcbiAgICB0aGlzLnNldEN1cnNvcihOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpXG4gICAgcmV0dXJuIHRoaXMubGVmdC5wb3AoKVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBzaW5nbGUgaXRlbSB0byB0aGUgaGlnaC1udW1iZXJlZCBzaWRlIG9mIHRoZSBhcnJheTtcbiAgICogbW92ZXMgdGhlIGN1cnNvciB0byBgbGVuZ3RoYC5cbiAgICpcbiAgICogQHBhcmFtIHtUfSBpdGVtXG4gICAqICAgSXRlbS5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICogICBOb3RoaW5nLlxuICAgKi9cbiAgcHVzaChpdGVtKSB7XG4gICAgdGhpcy5zZXRDdXJzb3IoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKVxuICAgIHRoaXMubGVmdC5wdXNoKGl0ZW0pXG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBtYW55IGl0ZW1zIHRvIHRoZSBoaWdoLW51bWJlcmVkIHNpZGUgb2YgdGhlIGFycmF5LlxuICAgKiBNb3ZlcyB0aGUgY3Vyc29yIHRvIGBsZW5ndGhgLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSBpdGVtc1xuICAgKiAgIEl0ZW1zLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiAgIE5vdGhpbmcuXG4gICAqL1xuICBwdXNoTWFueShpdGVtcykge1xuICAgIHRoaXMuc2V0Q3Vyc29yKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlcbiAgICBjaHVua2VkUHVzaCh0aGlzLmxlZnQsIGl0ZW1zKVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBzaW5nbGUgaXRlbSB0byB0aGUgbG93LW51bWJlcmVkIHNpZGUgb2YgdGhlIGFycmF5O1xuICAgKiBNb3ZlcyB0aGUgY3Vyc29yIHRvIGAwYC5cbiAgICpcbiAgICogQHBhcmFtIHtUfSBpdGVtXG4gICAqICAgSXRlbS5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICogICBOb3RoaW5nLlxuICAgKi9cbiAgdW5zaGlmdChpdGVtKSB7XG4gICAgdGhpcy5zZXRDdXJzb3IoMClcbiAgICB0aGlzLnJpZ2h0LnB1c2goaXRlbSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIG1hbnkgaXRlbXMgdG8gdGhlIGxvdy1udW1iZXJlZCBzaWRlIG9mIHRoZSBhcnJheTtcbiAgICogbW92ZXMgdGhlIGN1cnNvciB0byBgMGAuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8VD59IGl0ZW1zXG4gICAqICAgSXRlbXMuXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqICAgTm90aGluZy5cbiAgICovXG4gIHVuc2hpZnRNYW55KGl0ZW1zKSB7XG4gICAgdGhpcy5zZXRDdXJzb3IoMClcbiAgICBjaHVua2VkUHVzaCh0aGlzLnJpZ2h0LCBpdGVtcy5yZXZlcnNlKCkpXG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgY3Vyc29yIHRvIGEgc3BlY2lmaWMgcG9zaXRpb24gaW4gdGhlIGFycmF5LiBSZXF1aXJlc1xuICAgKiB0aW1lIHByb3BvcnRpb25hbCB0byB0aGUgZGlzdGFuY2UgbW92ZWQuXG4gICAqXG4gICAqIElmIGBuIDwgMGAsIHRoZSBjdXJzb3Igd2lsbCBlbmQgdXAgYXQgdGhlIGJlZ2lubmluZy5cbiAgICogSWYgYG4gPiBsZW5ndGhgLCB0aGUgY3Vyc29yIHdpbGwgZW5kIHVwIGF0IHRoZSBlbmQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gICAqICAgUG9zaXRpb24uXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICogICBOb3RoaW5nLlxuICAgKi9cbiAgc2V0Q3Vyc29yKG4pIHtcbiAgICBpZiAoXG4gICAgICBuID09PSB0aGlzLmxlZnQubGVuZ3RoIHx8XG4gICAgICAobiA+IHRoaXMubGVmdC5sZW5ndGggJiYgdGhpcy5yaWdodC5sZW5ndGggPT09IDApIHx8XG4gICAgICAobiA8IDAgJiYgdGhpcy5sZWZ0Lmxlbmd0aCA9PT0gMClcbiAgICApXG4gICAgICByZXR1cm5cbiAgICBpZiAobiA8IHRoaXMubGVmdC5sZW5ndGgpIHtcbiAgICAgIC8vIE1vdmUgY3Vyc29yIHRvIHRoZSB0aGlzLmxlZnRcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSB0aGlzLmxlZnQuc3BsaWNlKG4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlcbiAgICAgIGNodW5rZWRQdXNoKHRoaXMucmlnaHQsIHJlbW92ZWQucmV2ZXJzZSgpKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGN1cnNvciB0byB0aGUgdGhpcy5yaWdodFxuICAgICAgY29uc3QgcmVtb3ZlZCA9IHRoaXMucmlnaHQuc3BsaWNlKFxuICAgICAgICB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5yaWdodC5sZW5ndGggLSBuLFxuICAgICAgICBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgICAgIClcbiAgICAgIGNodW5rZWRQdXNoKHRoaXMubGVmdCwgcmVtb3ZlZC5yZXZlcnNlKCkpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQXZvaWQgc3RhY2sgb3ZlcmZsb3cgYnkgcHVzaGluZyBpdGVtcyBvbnRvIHRoZSBzdGFjayBpbiBzZWdtZW50c1xuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiAgIEl0ZW0gdHlwZS5cbiAqIEBwYXJhbSB7QXJyYXk8VD59IGxpc3RcbiAqICAgTGlzdCB0byBpbmplY3QgaW50by5cbiAqIEBwYXJhbSB7UmVhZG9ubHlBcnJheTxUPn0gcmlnaHRcbiAqICAgSXRlbXMgdG8gaW5qZWN0LlxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiBjaHVua2VkUHVzaChsaXN0LCByaWdodCkge1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgbGV0IGNodW5rU3RhcnQgPSAwXG5cbiAgaWYgKHJpZ2h0Lmxlbmd0aCA8IGNvbnN0YW50cy52OE1heFNhZmVDaHVua1NpemUpIHtcbiAgICBsaXN0LnB1c2goLi4ucmlnaHQpXG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGNodW5rU3RhcnQgPCByaWdodC5sZW5ndGgpIHtcbiAgICAgIGxpc3QucHVzaChcbiAgICAgICAgLi4ucmlnaHQuc2xpY2UoY2h1bmtTdGFydCwgY2h1bmtTdGFydCArIGNvbnN0YW50cy52OE1heFNhZmVDaHVua1NpemUpXG4gICAgICApXG4gICAgICBjaHVua1N0YXJ0ICs9IGNvbnN0YW50cy52OE1heFNhZmVDaHVua1NpemVcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJjb25zdGFudHMiLCJTcGxpY2VCdWZmZXIiLCJjb25zdHJ1Y3RvciIsImluaXRpYWwiLCJsZWZ0IiwicmlnaHQiLCJnZXQiLCJpbmRleCIsImxlbmd0aCIsIlJhbmdlRXJyb3IiLCJzaGlmdCIsInNldEN1cnNvciIsInBvcCIsInNsaWNlIiwic3RhcnQiLCJlbmQiLCJzdG9wIiwidW5kZWZpbmVkIiwiTnVtYmVyIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJyZXZlcnNlIiwiY29uY2F0Iiwic3BsaWNlIiwiZGVsZXRlQ291bnQiLCJpdGVtcyIsImNvdW50IiwiTWF0aCIsInRydW5jIiwicmVtb3ZlZCIsImNodW5rZWRQdXNoIiwicHVzaCIsIml0ZW0iLCJwdXNoTWFueSIsInVuc2hpZnQiLCJ1bnNoaWZ0TWFueSIsIm4iLCJsaXN0IiwiY2h1bmtTdGFydCIsInY4TWF4U2FmZUNodW5rU2l6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micromark-util-subtokenize/dev/lib/splice-buffer.js\n");

/***/ })

};
;